PROBLEM STATEMENT:
You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.

Return the size of the largest island in grid after applying this operation.

An island is a 4-directionally connected group of 1s.

SOLUTION:

                                                                                              USING DISJOINT SET  
                                                                                              TIME COMPLEXITY: O(n*m)
                                                                                              SPACE COMPLEXITY: O(n*m)

class Solution {
    public int largestIsland(int[][] grid) {
        int n= grid.length;
        int m= grid[0].length;
        DisjointSet dis= new DisjointSet(n*m);
        int[] drow= {-1, 0, 1, 0};
        int[] dcol= {0, 1, 0, -1};
        //arrangements for all 1s
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int cellNo= (i*m)+j;
                if(grid[i][j]==1){
                    for(int k=0; k<4; k++){
                        int adjRow= i+drow[k];
                        int adjCol= j+dcol[k];
                        if(isValid(n,m,adjRow,adjCol) && grid[adjRow][adjCol]==1){
                            int adjCellNo= (adjRow*m)+adjCol;
                            if(dis.findUPar(cellNo) != dis.findUPar(adjCellNo)){
                                dis.unionBySize(cellNo, adjCellNo);
                            }
                        }
                    }
                }
            }
        }
        //arrangement f0r all 0s
        int maxi= Integer.MIN_VALUE;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                int cellNo= (i*m)+j;
                int size=1;
                if(grid[i][j]==0){
                    Set<Integer> uniqueParents= new HashSet<>();
                    for(int k=0; k<4; k++){
                        int adjRow= i+drow[k];
                        int adjCol= j+dcol[k];
                        if(isValid(n,m,adjRow,adjCol) && grid[adjRow][adjCol]==1){
                            int adjCellNo= (adjRow*m)+adjCol;
                            int ulp= dis.findUPar(adjCellNo);
                            if(!uniqueParents.contains(ulp)){
                                uniqueParents.add(ulp);
                                size+= dis.size.get(ulp);
                            }
                        }
                    }
                    maxi=Math.max(maxi,size);
                }
            }
        }
        return (maxi==Integer.MIN_VALUE) ? (n*m) : maxi;
    }
    public boolean isValid(int n, int m, int row, int col){
        if(row>=0 && row<n && col>=0 && col<m)  return true;
        else    return false;
    }
}
class DisjointSet{
    List<Integer> parent= new ArrayList<>();
    List<Integer> size= new ArrayList<>();

    DisjointSet(int n){
        for(int i=0; i<n; i++){
            parent.add(i);
            size.add(1);
        }
    }

    public int findUPar(int node){
        if(parent.get(node)==node)  return node;
        int ulp= findUPar(parent.get(node));
        parent.set(node, ulp);
        return ulp;
    }

    public void unionBySize(int u, int v){
        int ulp_u= findUPar(u);
        int ulp_v= findUPar(v);
        if(ulp_u == ulp_v)  return;
        if(size.get(ulp_u)<size.get(ulp_v)){
            parent.set(ulp_u, ulp_v);
            size.set(ulp_v, size.get(ulp_u)+ size.get(ulp_v));
        }
        else{
            parent.set(ulp_v, ulp_u);
            size.set(ulp_u, size.get(ulp_u)+ size.get(ulp_v));
        }
    }
}
