PROBLEM STATEMENT:
On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.

A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.

Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.

SOLUTION:

                                                                                USING DISJOINT SET
                                                                                TIME COMPLEXITY: O(N)
                                                                                SPACE COMPLEXITY: O(N)

class Solution {
    public int removeStones(int[][] stones) {
        int n= stones.length;  //number of stones
        
        Set<Integer> usedNodes= new HashSet<>();
        int maxRow=0;
        int maxCol=0;
        for(int i=0; i<stones.length; i++){
            maxRow= Math.max(maxRow, stones[i][0]);
            maxCol= Math.max(maxCol, stones[i][1]);
        }
        DisjointSet dis= new DisjointSet(maxRow+maxCol+2);
        int components=0;
        for(int i=0; i<stones.length; i++){
            int row= stones[i][0];
            int col= stones[i][1]+maxRow+1;

            dis.unionByRank(row,col);
            
            usedNodes.add(row);
            usedNodes.add(col);

        }

        for(int node: usedNodes){
            if(dis.findUPar(node)==node)    components++;
        }

        return n-components;
    }
}
class DisjointSet{
    List<Integer> parent= new ArrayList<>();
    List<Integer> rank= new ArrayList<>();
    
    public DisjointSet(int n){
        for(int i=0; i<n; i++){
            parent.add(i);
            rank.add(0);
        }
    }
    
    public int findUPar(int node){
        if(node==parent.get(node))  return node;
        int ulp= findUPar(parent.get(node));
        parent.set(node, ulp);
        
        return ulp;
    }
    
    public void unionByRank(int u, int v){
        int ulp_u= findUPar(u);
        int ulp_v= findUPar(v);
        
        if(ulp_u == ulp_v)  return;
        
        if(rank.get(ulp_u) < rank.get(ulp_v)){
            parent.set(ulp_u, ulp_v);
        }
        else if(rank.get(ulp_v)<rank.get(ulp_u)){
            parent.set(ulp_v, ulp_u);
        }
        else{
            parent.set(ulp_v, ulp_u);
            int rankU= rank.get(ulp_u);
            rank.set(ulp_u, rankU+1);
        }
    }
}
