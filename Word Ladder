PROBLEM STATEMENT:
A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:

Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.

SOLUTION:                                    USING BFS

class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        
        Queue<Pair> q= new LinkedList<>();
        q.add(new Pair(beginWord, 1)); 
        HashSet<String> set= new HashSet<>();
        for(String word: wordList){
            set.add(word);
        }

        while(!q.isEmpty()){
            Pair pair= q.poll();
            String word= pair.word;
            int level= pair.level;
            if(word.equals(endWord))    return level;
            for(int i=0; i<word.length(); i++){
                StringBuilder sb= new StringBuilder(word);
                for(char ch='a'; ch<='z'; ch++){
                    sb.setCharAt(i,ch);
                    if(set.contains(sb.toString())){
                        set.remove(sb.toString());
                        q.add(new Pair(sb.toString(),level+1));
                    }

                }
            }
        }
        return 0;
    }
}
class Pair{
    String word;
    int level;
    Pair(String word, int level){
        this.word= word;
        this.level= level;
    }
}
