PROBLEM STATEMENT:
A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:

Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].


SOLUTION:
                                                                                              TIME COMPLEXITY: O(N × L × P)
                                                                                              SPACE COMPLEXITY: O(N × d + P × d)
  
class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        
        HashSet<String> set= new HashSet<>();
        for(String str:wordList){
            set.add(str);
        }
        
        List<String> list= new ArrayList<>();
        Queue<List<String>> q= new LinkedList<>();
        list.add(beginWord);
        q.add(new ArrayList<>(list));

        List<String> usedOnLevel=new ArrayList<>();
        usedOnLevel.add(beginWord);

        List<List<String>> result= new ArrayList<>();
        boolean foundEnd= false;
        if (!set.contains(endWord)) return result;

        int level=1;

        while(!q.isEmpty()){
            List<String> qList= q.poll();

            if(qList.size() > level){
                level++;
                for(String it: usedOnLevel){
                    set.remove(it);
                }
                usedOnLevel.clear();
                if(foundEnd)    break;
            }

            String word= qList.get(qList.size()-1);
            if(word.equals(endWord)){
                int size= qList.size();
                result.add(qList);
                foundEnd= true;
                continue;
            }
            for(int i=0; i<word.length(); i++){
                StringBuilder sb= new StringBuilder(word);
                for(char ch='a'; ch<='z'; ch++){
                    sb.setCharAt(i,ch);
                    String newWord= sb.toString();
                    if(set.contains(newWord)){
                        List<String> newList= new ArrayList<>(qList);
                        newList.add(newWord);
                        q.add(newList);
                        usedOnLevel.add(newWord);
                    }
                }
            }

        }

        return result;
    }
}
